## 1.  线性表的定义和基本操作
####    1.1 线性表的定义
    ---《王道数据结构》
    
    线性表事具有相同的数据结构的n（n>=0）个数据元素的有限序列，其中n为表长，当n=0时，该表是一个空表。
    
    线性表中的第一个元素成为表头元素，最后一个元素称为表尾元素。
    
    除了第一个元素外，每个元素有且仅有一个直接前驱。
    除了最后一个元素外，每个元素有且仅有一个直接后继。
    
    线性表的特点：
        1、表中的元素个数有限。
        2、表中的元素具有逻辑上的顺序性，在序列中各元素排序有其先后次序。
        3、表中的元素都是数据元素，每个元素都是单个元素。
        4、表中的元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。
        5、表中的元素具有抽象性，即，仅讨论元素间的逻辑关系，而不考虑元素究竟表达什么内容。

---

####     1.2 线性表的基本操作
    ---《王道数据结构》
    
    线性表的主要操作如下：
        1、InitList(&L):初始化表,构造一个空的线性表。
        2、Length(L):求表长，返回线性表L的长度，即L中数据元素的个数。
        3、LocationElem(L, e):按值查找操作，在表L中查找具有给定关键字值的元素。
        4、GetElem(L, i):按位查找操作，获取表L中第i个位置的元素的值。
        5、ListInsert(&L, i, e):插入操作，在表L中的第i个位置插入指定元素e。
        6、ListDelete(&L, i, &e):删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值。
        7、PrintList(L):输出操作
        8、Empty(L):判空操作
        9、DestroyList(&L):销毁操作
        
## 2.  线性表的顺序表示---顺序表
####     2.1 顺序表的定义
    ---《王道数据结构》
    线性表的顺序存储又称为 顺序表。
    顺序表是一组地址连续的存储单位依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。
    
######      2.1.1 顺序表内存地址
        假设线性表L存储的起始位置为LOC(A), sizeof(ElemType)是每个元素所占的存储的大小。
        则：
            a1 的下标为 0, 存储地址为LOC(A);
            a2 的下标为 1, 存储地址为LOC(A) + sizeof(ElemType);
            ....
            an 的下标为 n-1, 存储地址为LOC(A) +[(n-1) * sizeof(ElemType)] ;
            
######      2.1.2 顺序表内存地址
    - 顺序表最主要的特点是随机访问，即，通过首地址和元素序号可在时间O(1)内找到指定的元素。
    - 顺序表的存储密度高。每个结点只存储数据元素。
    - 顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。
    
---
####     2.2 顺序表上基本操作的实现
    ---《王道数据结构》
-   插入操作
        
        描述：在顺序表L的第i(1 <= i <= L.length + 1)个位置插入新元素e。

        思路：1、需要进行输入条件判断，判断是否合理输入。
             2、将顺序表的第i个元素及其后的所有元素右移一个位置。
             3、将e插入这个空位置。
             4、顺序表长度增加1。
             
        代码：
        // L.length —> 当前数组的元素个数；例如[0,1,2].length = 3;
        // 0的下标为0，1的下标为1，2的下标位2
        
        //！！！注意：这里的i的取值为[1,L.length+1];
        //  这里的i指的是顺序表的位序
        //  能取到L.length + 1的原因是因为L的MaxSize大于L.length，所以可以在第L.length + 1位插入。
        //  这题也可以使用i为下标表示。
        
            bool ListInsert(SqList &L, i, Elemtype e) {
                //判断输入条件
                //首先判断表是否满了
                if (L.length >= MaxSize)
                    return false;
                //其次判断插入位置的输入条件是否符合
                //i是插入位置，L的位置是 1到L.length + 1
                if (i < 1 || i > L.length + 1) 
                    return false;
                //主操作
                for (int j = L.length; j >= i; --j) {
                    L.data[j] = L.data[j - 1];
                }
                L.data[i - 1] = e;
                L.length++;
                return true;
            }
            
        时间复杂度分析：
            最好情况：在表尾插入(i = n + 1),元素不需要后移，所以时间复杂度为O(1)；
            最坏情况：在表头插入(i = 1)，元素后移语句执行n次，时间复杂度为O(n)；
            平均情况：假设pi(pi = 1/ n+1),则在长度为n的线性表中插入一个结点的时间复杂度：n / 2 => O(n)
-   删除操作
        
        描述：删除顺序表中第i（1<=i<=L.length）个位置的元素。

        思路：1、判断输入参数是否合理。
             2、将下标为i-1的元素删除。并赋值给e,以便返回。
             3、将第i个位置后的元素依次左移。
             4、顺序表长度减少1.
             
        代码：
            // 注意这里i的取值为[1, L.length];
            // 这里的i指的是顺序表的位序
            
            bool ListDelete(SqList &L, int i, ElemType &e) {
                if (i < 1 || i > L.length) 
                    return false;
                e = L.data[i - 1];  //注意i是顺序表的位序，这里要使用下标。
                for (int j = i; j <= L.length - 1; j++) {
                    L.data[j - 1] = L.data[j];
                }
                L.length --;
                return true;
            }
        
        时间复杂度分析：
            最好情况：删除表尾（i=n）,时间复杂度为O(1)。
            最坏情况：删除表头（i=1）,时间复杂度为O(n)。
            平均情况：Pi=1/n,时间复杂度（n-1）/2。
-   按值查找
        
        描述：在顺序表中查找第一个元素值为e的元素，并返回其位序。
        
        思路：1、直接遍历。
              2、如果是有序顺序表，可以使用二分查找，但是需要注意找第一个元素值为e.
        
        代码：
            int LocateElem(SqList L, ElemType) {
                int i;
                for (i = 0; i <= L.length - 1; i++) {
                    if (L.data[i] == 0)
                        return i + 1;
                }
                return 0;
            }

        时间复杂度分析：
            最好情况：查找的元素在表头，时间复杂度为O(1)
            最坏情况：查找的元素在表尾或者不存在，时间复杂度为O(n)
            平均情况：pi=1/n,时间复杂度为（n+1）/2

---

## 3.  线性表的链式表示---链表
    
    ---《大话数据结构》
    
    1、链表的定义：
        为了表示每个数据元素ai与其后直接后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需要存储一个指示其直接后继的信息（即直接后继的存储位置）。
        把存储数据元素信息的域称为数据域；
        把存储直接后继位置的域称为指针域；指针域中存储的信息称做指针或链。
        这两部分的信息组成数据元素ai的存储映像，称为结点（Node）。
        n个结点链结成一个链表，即为线性表的链式存储。

    2、头指针：链表中第一个结点的存储位置叫做头指针。
        头结点：链表的第一个结点前附设一个结点。

        头指针和头结点的区别：
            头指针：
                ·头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。 //第一个结点：如果没有头结点，第一个结点就是首个元素，如果有头结点，第一个结点就是头结点。
                ·头指针具有标识作用，所以常用头指针冠以链表的名字。
                ·不论链表是否为空，头指针均不为空。头指针是链表的必要元素。
            
            头结点：
                ·头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可以存放链表的长度）。
                ·有了头结点，对在第一元素结点前插入和删除第一结点，其操作与其他结点的操作就统一了。
                ·头结点不一定是链表必须要素。

    3、链表的特点：
        ·链表可以解决顺序表需要大量连续存储空间的缺点。
        ·链表附加指针域，存在浪费存储空间的缺点。
        ·链表是非随机存取的存储结构。查找某个特定结点时，需要从表头开始遍历，依次查找。
---
#### 3.1 单链表的定义

    线性表的链式存储又称单链表。它是指通过一组任意的存储单元来存储线性表中的数据元素。
    为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针。
    
    单链表的结构类型：
        typedef struct LNode {
            ElemType data;        //数据域
            struct LNode *next;   //指针域
        }LNode, *LinkList;
        //结点是由存放数据元素的数据域和存放后继结点地址的指针域组成。

---

#### 3.2 单链表上基本操作的实现
###### 3.2.1 采用头插法建立单链表

        思路：1、生成一个新的结点
             2、获取头结点的next指针，将头结点的next指针赋值给新结点的next指针。
             3、将头结点的next指针指向新结点。

        代码： 
            LinkList List_HeadInsert(LinkList &L) {
                LNode *s;           //新结点
                int x;              //结点的值
                L = (LinkList)malloc(sizeof(LNode));    //创建头结点
                L -> next = NUll;                       //初始为空表
                scanf("%d", &x);                        //输入结点的值
                while(x != 9999) {                      //输入9999表示结束
                    s = (LNode *)malloc(sizeof(LNode)); //创建新结点
                    s -> data = x;                      //s的数据域赋值
                    s -> next = L->next;                //思路-2:将头结点的next赋值给新结点
                    L -> next = s;                       //思路-3:将头结点的next重新指向新结点，
                    scanf("%d", x);
                }

                return L;
            }

        时间复杂度分析：
            采用头插法建立单链表时，读入数据的顺序与生成的链表中的元素的顺序是相反的。每个结点的插入时间为O(1),则总时间复杂度为O(n)。

---
###### 3.2.2 采用尾插法建立单链表
        
        思路：1、增加一个尾指针r，使其指向当前链表的尾结点。
             2、生成一个新结点。
             3、尾指针的next指针指向新结点。
             4、将新的结点指针赋值给尾指针
        
        代码：
            LinkList List_TailInsert(LinkList &L) {
                int x;
                L = (LinkList)malloc(sizeof(LNode));
                LNode *s, *r=L;                     //r为表尾指针
                scanf("%d", &x);
                while(x != 9999) {
                    s = (LNode *)malloc(sizeof(LNode));
                    s -> data = x;
                    r -> next = s;                  //尾指针指向新的结点
                    r = s;                          //r指向新的表尾结点
                    scanf("%d", &x);
                }
                r -> next = NULL;                   //结束时尾指针置位空
                return L;
            }

        时间复杂度：
            因为设立了一个尾指针，所以时间复杂度和上一个相同。
###### 3.2.3 按序号查找结点值

        思路：从单链表一个一个往下找，直到第i个结点为止。

        代码：
            LNode *GetElem(LinkList L, Int i) {
                int j = 1;              //计数，初始为1.
                LNode *p = L ->next;    //头结点指针赋值给p
                if (i = 0) 
                    return L;
                if (i < 1)
                    return NULL;
                while (p && j < i) {    //p存在且j < i
                    p = p->next;        //将下一结点指针赋值给p
                    j++;                //计数+1
                }
                return p;               //当j = i 时循环结束。返回当前的p指针。
            }
        
        时间复杂度分析：
            O(n)
###### 3.2.4 按值查找表结点
###### 3.2.5 插入结点操作
###### 3.2.6 删除结点操作
###### 3.2.7 求表厂操作



#### 3.3 双链表

###### 3.2.1 采用尾插法建立双链表
###### 3.2.2 双链表的插入结点操作
###### 3.2.2 双链表的删除结点操作


#### 3.4 循环链表

###### 3.4.1 循环单链表
###### 3.4.2 循环双链表



#### 3.5 静态链表


#### 3.6 顺序表和链表的比较
