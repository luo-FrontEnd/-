## 1.  线性表的定义和基本操作
####    1.1 线性表的定义
    
    线性表事具有相同的数据结构的n（n>=0）个数据元素的有限序列，其中n为表长，当n=0时，该表是一个空表。
    
    线性表中的第一个元素成为表头元素，最后一个元素称为表尾元素。
    
    除了第一个元素外，每个元素有且仅有一个直接前驱。
    除了最后一个元素外，每个元素有且仅有一个直接后继。
    
    线性表的特点：
        1、表中的元素个数有限。
        2、表中的元素具有逻辑上的顺序性，在序列中各元素排序有其先后次序。
        3、表中的元素都是数据元素，每个元素都是单个元素。
        4、表中的元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。
        5、表中的元素具有抽象性，即，仅讨论元素间的逻辑关系，而不考虑元素究竟表达什么内容。

---

####     1.2 线性表的基本操作
    
    线性表的主要操作如下：
        1、InitList(&L):初始化表,构造一个空的线性表。
        2、Length(L):求表长，返回线性表L的长度，即L中数据元素的个数。
        3、LocationElem(L, e):按值查找操作，在表L中查找具有给定关键字值的元素。
        4、GetElem(L, i):按位查找操作，获取表L中第i个位置的元素的值。
        5、ListInsert(&L, i, e):插入操作，在表L中的第i个位置插入指定元素e。
        6、ListDelete(&L, i, &e):删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值。
        7、PrintList(L):输出操作
        8、Empty(L):判空操作
        9、DestroyList(&L):销毁操作
        
## 2.  线性表的顺序表示---顺序表
####     2.1 顺序表的定义
    
    线性表的顺序存储又称为 顺序表。
    顺序表是一组地址连续的存储单位依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。
    
######      2.1.1 顺序表内存地址
        假设线性表L存储的起始位置为LOC(A), sizeof(ElemType)是每个元素所占的存储的大小。
        则：
            a1 的下标为 0, 存储地址为LOC(A);
            a2 的下标为 1, 存储地址为LOC(A) + sizeof(ElemType);
            ....
            an 的下标为 n-1, 存储地址为LOC(A) +[(n-1) * sizeof(ElemType)] ;
            
######      2.1.2 顺序表内存地址
    - 顺序表最主要的特点是随机访问，即，通过首地址和元素序号可在时间O(1)内找到指定的元素。
    - 顺序表的存储密度高。每个结点只存储数据元素。
    - 顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。
    
---
####     2.2 顺序表上基本操作的实现
-   插入操作
        
        描述：在顺序表L的第i(1 <= i <= L.length + 1)个位置插入新元素e。

        思路：1、需要进行输入条件判断，判断是否合理输入。
             2、将顺序表的第i个元素及其后的所有元素右移一个位置。
             3、将e插入这个空位置。
             4、顺序表长度增加1。
             
        代码：
        // L.length —> 当前数组的元素个数；例如[0,1,2].length = 3;
        // 0的下标为0，1的下标为1，2的下标位2
        
        //！！！注意：这里的i的取值为[1,L.length+1];
        //  这里的i指的是顺序表的位序
        //  能取到L.length + 1的原因是因为L的MaxSize大于L.length，所以可以在第L.length + 1位插入。
        //  这题也可以使用i为下标表示。
        
            bool ListInsert(SqList &L, i, Elemtype e) {
                //判断输入条件
                //首先判断表是否满了
                if (L.length >= MaxSize)
                    return false;
                //其次判断插入位置的输入条件是否符合
                //i是插入位置，L的位置是 1到L.length + 1
                if (i < 1 || i > L.length + 1) 
                    return false;
                //主操作
                for (int j = L.length; j >= i; --j) {
                    L.data[j] = L.data[j - 1];
                }
                L.data[i - 1] = e;
                L.length++;
                return true;
            }
            
        时间复杂度分析：
            最好情况：在表尾插入(i = n + 1),元素不需要后移，所以时间复杂度为O(1)；
            最坏情况：在表头插入(i = 1)，元素后移语句执行n次，时间复杂度为O(n)；
            平均情况：假设pi(pi = 1/ n+1),则在长度为n的线性表中插入一个结点的时间复杂度：n / 2 => O(n)
-   删除操作
        
        描述：删除顺序表中第i（1<=i<=L.length）个位置的元素。

        思路：1、判断输入参数是否合理。
             2、将下标为i-1的元素删除。并赋值给e,以便返回。
             3、将第i个位置后的元素依次左移。
             4、顺序表长度减少1.
             
        代码：
            // 注意这里i的取值为[1, L.length];
            // 这里的i指的是顺序表的位序
            
            bool ListDelete(SqList &L, int i, ElemType &e) {
                if (i < 1 || i > L.length) 
                    return false;
                e = L.data[i - 1];  //注意i是顺序表的位序，这里要使用下标。
                for (int j = i; j <= L.length - 1; j++) {
                    L.data[j - 1] = L.data[j];
                }
                L.length --;
                return true;
            }
        
        时间复杂度分析：
            最好情况：删除表尾（i=n）,时间复杂度为O(1)。
            最坏情况：删除表头（i=1）,时间复杂度为O(n)。
            平均情况：Pi=1/n,时间复杂度（n-1）/2。
-   按值查找
        
        描述：在顺序表中查找第一个元素值为e的元素，并返回其位序。
        
        思路：1、直接遍历。
              2、如果是有序顺序表，可以使用二分查找，但是需要注意找第一个元素值为e.
        
        代码：
            int LocateElem(SqList L, ElemType) {
                int i;
                for (i = 0; i <= L.length - 1; i++) {
                    if (L.data[i] == 0)
                        return i + 1;
                }
                return 0;
            }

        时间复杂度分析：
            最好情况：查找的元素在表头，时间复杂度为O(1)
            最坏情况：查找的元素在表尾或者不存在，时间复杂度为O(n)
            平均情况：pi=1/n,时间复杂度为（n+1）/2